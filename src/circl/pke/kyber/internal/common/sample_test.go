package common

import (
	"testing"
)

func TestPolyDeriveNoiseRef(t *testing.T) {
	var p Poly

	want := Poly{
		1, 0, 1, -1, -1, -2, -1, -1, 2, 0, -1, 0, 0, -1,
		1, 1, -1, 1, 0, 2, -2, 0, 1, 2, 0, 0, -1, 1, 0, -1,
		1, -1, 1, 2, 1, 1, 0, -1, 1, -1, -2, -1, 1, -1, -1,
		-1, 2, -1, -1, 0, 0, 1, 1, -1, 1, 1, 1, 1, -1, -2,
		0, 1, 0, 0, 2, 1, -1, 2, 0, 0, 1, 1, 0, -1, 0, 0,
		-1, -1, 2, 0, 1, -1, 2, -1, -1, -1, -1, 0, -2, 0,
		2, 1, 0, 0, 0, -1, 0, 0, 0, -1, -1, 0, -1, -1, 0,
		-1, 0, 0, -2, 1, 1, 0, 1, 0, 1, 0, 1, 1, -1, 2, 0,
		1, -1, 1, 2, 0, 0, 0, 0, -1, -1, -1, 0, 1, 0, -1,
		2, 0, 0, 1, 1, 1, 0, 1, -1, 1, 2, 1, 0, 2, -1, 1,
		-1, -2, -1, -2, -1, 1, 0, -2, -2, -1, 1, 0, 0, 0,
		0, 1, 0, 0, 0, 2, 2, 0, 1, 0, -1, -1, 0, 2, 0, 0,
		-2, 1, 0, 2, 1, -1, -2, 0, 0, -1, 1, 1, 0, 0, 2,
		0, 1, 1, -2, 1, -2, 1, 1, 0, 2, 0, -1, 0, -1, 0,
		1, 2, 0, 1, 0, -2, 1, -2, -2, 1, -1, 0, -1, 1, 1,
		0, 0, 0, 1, 0, -1, 1, 1, 0, 0, 0, 0, 1, 0, 1, -1,
		0, 1, -1, -1, 2, 0, 0, 1, -1, 0, 1, -1, 0,
	}

	var seed [32]byte

	for i := 0; i < 32; i++ {
		seed[i] = byte(i)
	}

	p.DeriveNoise(seed[:], 37)

	if p != want {
		t.Fatal()
	}
}

func TestPolyDeriveUniformRef(t *testing.T) {
	var p Poly

	// Generated by reference implementation.
	want := Poly{
		1564, 1330, 2158, 6, 925, 2968, 2602, 2716, 134,
		3054, 2194, 158, 1728, 1632, 2471, 3230, 1722, 3194,
		2139, 1143, 3319, 2146, 330, 1033, 1726, 580, 129,
		836, 2955, 3196, 1055, 1063, 2058, 736, 2458, 2912,
		2368, 1877, 1086, 1758, 3236, 2329, 2143, 1050,
		2703, 3235, 31, 2806, 1322, 2842, 3060, 1298, 1868,
		2633, 1863, 1346, 3269, 84, 740, 774, 2157, 2016,
		1105, 66, 412, 2358, 2852, 560, 407, 1336, 1911,
		2611, 1147, 1535, 595, 1334, 2397, 2919, 2893, 2228,
		915, 2171, 322, 475, 855, 1281, 1051, 2102, 279,
		357, 3317, 3175, 2663, 1783, 3219, 2220, 167, 2055,
		1161, 3087, 2709, 375, 2104, 585, 2881, 1891, 684,
		2929, 2991, 636, 1826, 1666, 593, 2912, 3173, 3111,
		119, 1269, 2552, 62, 1056, 1977, 2225, 2942, 1070,
		1668, 2730, 2396, 52, 2499, 1413, 273, 2170, 2107,
		1422, 2774, 186, 2573, 3252, 1412, 1263, 3160, 163,
		2849, 236, 459, 2772, 1128, 2775, 3267, 1755, 3209,
		2331, 2041, 271, 647, 1381, 3313, 174, 1377, 1960,
		1597, 1776, 751, 2034, 1912, 795, 2124, 730, 1642,
		1142, 520, 2659, 2797, 1314, 1187, 2914, 1998, 797,
		366, 2362, 1732, 742, 3132, 2950, 899, 794, 1554,
		2036, 1032, 1229, 484, 3069, 1344, 74, 2283, 1722,
		1365, 1724, 1957, 1140, 2038, 392, 1666, 3217, 392,
		2872, 605, 628, 439, 3268, 605, 3299, 2478, 2069,
		1387, 1680, 149, 2890, 368, 280, 2363, 585, 3312,
		2289, 2979, 589, 1418, 2371, 296, 1833, 1506, 931,
		2986, 101, 1797, 2176, 397, 1623, 2691, 1883, 474,
		1923, 1063, 2749, 1633, 2740, 3159, 1541, 1825,
		2546, 2504, 2368, 394, 2225, 2296,
	}

	var seed [32]byte

	for i := 0; i < 32; i++ {
		seed[i] = byte(i)
	}

	p.DeriveUniform(&seed, 1, 0)
	p.Normalize()

	if p != want {
		t.Fatal()
	}
}
